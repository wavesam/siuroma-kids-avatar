# 拖拽重复创建物品问题解决方案

## 问题描述

在换装游戏中，当用户从衣柜拖拽物品到画布上时，会出现重复创建物品的问题：
- 从衣柜拖拽物品到画布，会创建两个相同的物品实例
- 拖动已放置的物品时，会在原地留下一个相同的物品

## 问题根源分析

### 1. 事件触发机制冲突

系统中有两种拖拽机制：
- **HTML5 拖拽**：从衣柜拖拽物品到画布（`onDragStart` → `onDrop`）
- **鼠标拖拽**：拖动已放置的物品（`onMouseDown` → `onMouseMove` → `onMouseUp`）

当用户在 `body` 或 `accessories` tab（`snapItems = false`，`freelyDraggable = true`）中操作时，两种机制可能同时触发，导致：
1. 鼠标拖拽已放置物品时，浏览器可能同时触发 HTML5 拖拽事件
2. `handleDrop` 被误触发，调用 `placeClosetItem` 创建新物品
3. `setPlaced` 的回调函数可能被 React 调用多次（开发模式下的严格模式）

### 2. React 状态更新异步性

React 的状态更新是异步的，当快速连续调用时：
- `setDragPlacing` 更新后，`dragPlacingRef.current` 可能还未同步
- `handleDrop` 检查时可能读取到旧值，导致误判

### 3. 防重复逻辑不足

原有的 `shouldAcceptDrop` 函数：
- 只检查 250ms 内的重复，时间窗口可能不够
- 只检查 `dedupeKey`，但相同物品在不同位置可能通过检查

## 解决方案

### 方案 1: 在 `handleDrop` 中添加多层防护

**文件**: `src/components/AvatarCanvas.tsx`

#### 1.1 添加处理标志防止重复调用

```typescript
// Add a ref to track if we're processing a drop to prevent duplicate calls
const isProcessingDropRef = React.useRef(false);

const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
  e.preventDefault();
  
  // Prevent duplicate drop handling
  if (isProcessingDropRef.current) {
    console.log("❌ [handleDrop] 阻止：正在处理另一个 drop 事件");
    return;
  }
  
  // ... 其他逻辑
  
  // Mark as processing to prevent duplicate calls
  isProcessingDropRef.current = true;
  
  // Use setTimeout to reset the flag after a short delay
  setTimeout(() => {
    isProcessingDropRef.current = false;
  }, 100);
  
  placeClosetItem(id, tab, x, y);
};
```

#### 1.2 检查是否正在鼠标拖拽

```typescript
// Use ref for immediate check since state updates are async
if (dragPlacingRef.current) {
  console.log("❌ [handleDrop] 阻止：正在鼠标拖拽已放置物品");
  return;
}
```

#### 1.3 检查物品是否已在画布上

```typescript
// CRITICAL: If this is a freelyDraggable tab, check if the item is already placed
if (freelyDraggable) {
  const isAlreadyPlaced = placed.some((item) => item.id === id);
  if (isAlreadyPlaced) {
    console.log("❌ [handleDrop] 阻止：物品已在画布上");
    return;
  }
}
```

#### 1.4 检查 dataTransfer 格式

```typescript
// Only accept drops that have the proper MIME type from the closet
const hasClosetMimeType = e.dataTransfer.types.includes("application/x-avatar-item-id");
if (!hasClosetMimeType && e.dataTransfer.getData("text/plain")) {
  const textId = e.dataTransfer.getData("text/plain");
  if (placed.some((item) => item.id === textId)) {
    console.log("❌ [handleDrop] 阻止：只有 text/plain 且物品已在画布上");
    return;
  }
}
```

### 方案 2: 在 `placeClosetItem` 中添加防重复逻辑

**文件**: `src/components/AvatarStudio.tsx`

#### 2.1 添加函数级防重复标志

```typescript
// Add a ref to prevent duplicate execution of placeClosetItem
const isPlacingItemRef = React.useRef(false);

const placeClosetItem = (
  closetId: string,
  targetTab: TabKey,
  dropX?: number,
  dropY?: number
) => {
  // Prevent duplicate execution
  if (isPlacingItemRef.current) {
    console.log("❌ [placeClosetItem] 阻止：正在处理另一个放置操作");
    return;
  }
  
  // Mark as processing
  isPlacingItemRef.current = true;
  
  // ... 其他逻辑
};
```

#### 2.2 在 setPlaced 回调中检查重复

```typescript
setPlaced((current) => {
  // Double-check inside the callback to prevent duplicate additions
  const existingInstance = current.find(
    (p) => p.id === closetId && Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5
  );
  if (existingInstance) {
    console.log("❌ [placeClosetItem setPlaced] 阻止：相同位置已有实例");
    isPlacingItemRef.current = false;
    return current;
  }
  
  // ... 创建新实例的逻辑
  
  // Reset the flag after a short delay
  setTimeout(() => {
    isPlacingItemRef.current = false;
  }, 100);
  
  return [...filtered, newItem];
});
```

### 方案 3: 阻止已放置物品的 HTML5 拖拽

**文件**: `src/components/AvatarCanvas.tsx`

```typescript
onDragStart={(e) => {
  // CRITICAL: Prevent HTML5 drag when using mouse drag for placed items
  if (freelyDraggable || dragPlacingRef.current) {
    console.log("🚫 [onDragStart] 阻止 HTML5 拖拽已放置物品");
    e.preventDefault();
    e.stopPropagation();
    // Clear any data that might have been set
    e.dataTransfer.clearData();
    e.dataTransfer.effectAllowed = "none";
    return false;
  }
}}
```

### 方案 4: 加强 shouldAcceptDrop 防重复逻辑

**文件**: `src/components/AvatarStudio.tsx`

```typescript
// Dedupe drops - 将防重复时间从 250ms 增加到 500ms
const shouldAcceptDrop = (key: string) => {
  const now = performance.now();
  const last = lastDropRef.current;
  if (last && last.key === key && now - last.t < 500) {
    console.log("❌ [shouldAcceptDrop] 阻止重复放置", {
      key,
      timeSinceLast: now - last.t,
    });
    return false;
  }
  lastDropRef.current = { key, t: now };
  console.log("✅ [shouldAcceptDrop] 允许放置", { key, time: now });
  return true;
};
```

## 关键修复点总结

### 1. 使用 Ref 进行立即检查

**问题**: React 状态更新是异步的，使用 state 检查可能读取到旧值

**解决**: 使用 `ref` 来立即跟踪状态
- `dragPlacingRef` - 跟踪是否正在鼠标拖拽
- `isProcessingDropRef` - 跟踪是否正在处理 drop 事件
- `isPlacingItemRef` - 跟踪是否正在放置物品

### 2. 多层防护机制

在不同层级添加检查：
1. **事件层**: `onDragStart` 阻止 HTML5 拖拽
2. **处理层**: `handleDrop` 检查多个条件
3. **函数层**: `placeClosetItem` 防止重复调用
4. **状态层**: `setPlaced` 回调中检查重复实例

### 3. 时间窗口控制

- `isProcessingDropRef` 在 100ms 后重置
- `isPlacingItemRef` 在 100ms 后重置
- `shouldAcceptDrop` 检查 500ms 内的重复

### 4. 位置检查

在 `setPlaced` 回调中检查相同位置（5px 容差）是否已有实例，防止重复添加。

## 调试日志

添加了详细的控制台日志，方便追踪问题：

- `🎒 [Closet onDragStart]` - 从衣柜开始拖拽
- `🖱️ [Mouse Drag Start]` - 鼠标拖动已放置物品
- `🚫 [onDragStart]` - 阻止 HTML5 拖拽
- `📦 [handleDrop]` - Drop 事件触发
- `✅ [handleDrop]` - 允许放置
- `❌ [handleDrop]` - 阻止放置（各种原因）
- `✅ [placeClosetItem]` - 放置物品到画布
- `📝 [placeClosetItem]` - 创建新实例
- `❌ [placeClosetItem]` - 阻止操作（各种原因）
- `✅ [shouldAcceptDrop]` - 允许放置
- `❌ [shouldAcceptDrop]` - 阻止重复放置

## 测试验证

修复后，以下场景应该正常工作：

1. ✅ 从衣柜拖拽物品到画布，只创建一个实例
2. ✅ 拖动已放置的物品，不会在原地留下副本
3. ✅ 快速连续拖拽，不会创建重复物品
4. ✅ 在不同 tab 之间切换，拖拽功能正常

## 相关文件

- `src/components/AvatarCanvas.tsx` - 画布组件，处理拖放事件
- `src/components/AvatarStudio.tsx` - 主组件，管理状态和放置逻辑
- `src/components/Closet.tsx` - 衣柜组件，处理拖拽开始

## 注意事项

1. **开发模式**: React 18 的严格模式在开发环境下会故意调用某些函数两次，这是正常的，生产环境不会有这个问题
2. **时间窗口**: 防重复的时间窗口（100ms, 500ms）可能需要根据实际使用情况调整
3. **位置容差**: 检查相同位置时的 5px 容差可能需要根据物品大小调整

## 后续优化建议

1. 考虑使用 `useCallback` 和 `useMemo` 优化性能
2. 可以考虑使用状态管理库（如 Redux）来更好地管理拖拽状态
3. 可以添加单元测试来验证防重复逻辑

